# ランキング履歴管理機能

## 概要

企業の順位変動を追跡し、履歴として記録する機能です。`CompanyRankingHistoryService`を通じて、順位変動の計算・記録・分析を行います。

## 機能仕様

### 1. 順位変動の記録

ランキング計算が実行されるたびに、前回の順位との比較を行い、変動を記録します。

#### 順位変動の計算ロジック
- **上昇**: 前回の順位より現在の順位が高い（数字が小さい）場合、正の値で記録
- **下降**: 前回の順位より現在の順位が低い（数字が大きい）場合、負の値で記録
- **変動なし**: 前回と同じ順位の場合は0で記録
- **初回**: 前回のデータが存在しない場合は記録しない

#### 例
```
前回順位: 5位、現在順位: 3位 → rank_change = 2 (上昇)
前回順位: 3位、現在順位: 7位 → rank_change = -4 (下降)
前回順位: 5位、現在順位: 5位 → rank_change = 0 (変動なし)
```

### 2. データ構造

#### company_ranking_history テーブル
```sql
CREATE TABLE company_ranking_history (
    id BIGSERIAL PRIMARY KEY,
    company_id BIGINT NOT NULL REFERENCES companies(id),
    period_type VARCHAR(10) NOT NULL, -- 1w, 1m, 3m, 6m, 1y, 3y, all
    current_rank INTEGER NOT NULL,
    previous_rank INTEGER NULL, -- 前回の順位（初回は NULL）
    rank_change INTEGER NULL, -- 前回からの順位変動
    calculated_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### インデックス設計
- `idx_history_company_period`: 企業別・期間別の履歴検索
- `idx_history_period_calculated`: 期間別・計算日時での検索
- `idx_history_calculated_at`: 計算日時での検索
- `uniq_history_company_period_calc`: 重複レコード防止

### 3. 主要メソッド

#### 3.1 順位変動の記録
```php
public function recordRankingHistory(string $periodType, Carbon $calculatedAt): array
```
- 指定期間の順位変動を計算し、履歴として記録
- 前回のランキングと比較して変動を計算
- 変動情報を配列で返却

#### 3.2 企業の履歴取得
```php
public function getCompanyRankingHistory(int $companyId, string $periodType, int $days = 30): array
```
- 特定企業の順位変動履歴を取得
- 指定期間内の履歴データを時系列で取得

#### 3.3 上昇企業の取得
```php
public function getTopRankingRisers(string $periodType, int $limit = 10): array
```
- 最新の計算結果で最も順位が上昇した企業を取得
- 順位上昇幅の大きい順にソート

#### 3.4 下降企業の取得
```php
public function getTopRankingFallers(string $periodType, int $limit = 10): array
```
- 最新の計算結果で最も順位が下降した企業を取得
- 順位下降幅の大きい順にソート

#### 3.5 変動統計の取得
```php
public function getRankingChangeStatistics(string $periodType): array
```
- 順位変動の統計情報を取得
- 上昇・下降・変動なしの企業数
- 最大上昇・下降幅

### 4. データ管理

#### 4.1 古いデータの削除
```php
public function cleanupOldHistory(): int
```
- 365日を超える古い履歴データを自動削除
- パフォーマンス維持のための定期クリーンアップ

#### 4.2 ストレージ統計
```php
public function getHistoryStorageStats(): array
```
- 履歴データのストレージ使用状況を取得
- 総レコード数、企業数、期間タイプ数

### 5. 使用例

#### 5.1 履歴記録の実行
```php
use App\Services\CompanyRankingHistoryService;
use Carbon\Carbon;

$historyService = new CompanyRankingHistoryService();

// 1週間ランキングの履歴を記録
$changes = $historyService->recordRankingHistory('1w', Carbon::now());

foreach ($changes as $change) {
    echo "Company {$change['company_id']}: {$change['current_rank']} (change: {$change['rank_change']})\n";
}
```

#### 5.2 上昇企業の取得
```php
$risers = $historyService->getTopRankingRisers('1w', 5);

foreach ($risers as $riser) {
    echo "{$riser->company_name}: {$riser->previous_rank} → {$riser->current_rank} (+{$riser->rank_change})\n";
}
```

#### 5.3 企業の履歴分析
```php
$companyHistory = $historyService->getCompanyRankingHistory(1, '1w', 30);

foreach ($companyHistory as $history) {
    $change = $history->rank_change > 0 ? "↑{$history->rank_change}" : 
              ($history->rank_change < 0 ? "↓".abs($history->rank_change) : "=");
    echo "{$history->calculated_at}: {$history->current_rank}位 {$change}\n";
}
```

### 6. パフォーマンス最適化

#### 6.1 インデックス活用
- 複合インデックスによる高速検索
- ユニークインデックスによる重複防止

#### 6.2 データ保持期間
- 365日を超える履歴データの自動削除
- 定期的なクリーンアップ処理

#### 6.3 効率的なクエリ
- 最新データのみを対象とした集計
- 必要最小限のカラム選択

### 7. 運用考慮事項

#### 7.1 データの整合性
- ランキング計算と履歴記録の同期
- トランザクションによる一貫性保証

#### 7.2 モニタリング
- 履歴データの増加率監視
- 異常な順位変動の検出

#### 7.3 バックアップ
- 履歴データの定期バックアップ
- 長期保存データの別途管理

## 関連ドキュメント

- [期間別ランキング機能](期間別ランキング機能.md)
- [データベース設計](データベース設計.md)
- [開発フロー](開発フロー.md)